MODULE FXTRAN_ACDC_PARALLELMETHOD_MOD

!
! Copyright 2025 Meteo-France
! All rights reserved
! philippe.marguinaud@meteo.fr
!

IMPLICIT NONE

PRIVATE 
PUBLIC :: FXTRAN_ACDC_LPARALLELMETHOD, FXTRAN_ACDC_LSYNCHOST

CONTAINS

LOGICAL FUNCTION FXTRAN_ACDC_LPARALLELMETHOD (CDMETHOD, CDNAME) 

IMPLICIT NONE

CHARACTER (LEN=*),   INTENT (IN) :: CDMETHOD
CHARACTER (LEN=*),   INTENT (IN) :: CDNAME


CHARACTER (LEN=*), PARAMETER :: CLFILE = 'fxtran.acdc.parallelmethod.txt'
CHARACTER (LEN=256) :: CLMETHOD1, CLMETHOD2
CHARACTER (LEN=256) :: CLMETHOD

CHARACTER (LEN=256), ALLOCATABLE, SAVE :: CLNAMES (:)
CHARACTER (LEN=256), ALLOCATABLE, SAVE :: CLMETHODS (:)
INTEGER, ALLOCATABLE, SAVE :: ILNAMES (:)
LOGICAL, SAVE :: LLVERBOSE = .FALSE.
LOGICAL, SAVE :: LLINIT = .FALSE.

INTEGER :: ICOUNT, IERR, I
INTEGER, SAVE :: IDX = -1
INTEGER :: ILNAME
CHARACTER (LEN=16) :: CLENV

IF (.NOT. LLINIT) THEN

  CALL COUNTLINES (ICOUNT, CLFILE, IERR)
  CALL GETENV ('FXTRAN_ACDC_PARALLELMETHOD_VERBOSE', CLENV)
  LLVERBOSE = TRIM (CLENV) /= '' .AND. TRIM (CLENV) /= '0'

  IF (IERR == 0) THEN

    ALLOCATE (CLNAMES (ICOUNT), CLMETHODS (ICOUNT), ILNAMES (ICOUNT))
    OPEN (77, FILE=CLFILE, FORM='FORMATTED')
    DO I = 1, ICOUNT
      READ (77, *) CLMETHODS (I), CLNAMES (I)
      ILNAMES (I) = LEN_TRIM (CLNAMES (I))
    ENDDO
    CLOSE (77)

    IF (LLVERBOSE) THEN
      WRITE (0, *) "------ "//TRIM (CLFILE)//" ------"
      DO I = 1, SIZE (CLNAMES)
        WRITE (0, '(A32," ",A)') CLMETHODS (I), TRIM (CLNAMES (I))
      ENDDO
      WRITE (0, *) "------ "//TRIM (CLFILE)//" ------"
    ENDIF

  ENDIF

  LLINIT = .TRUE.

ENDIF

CALL UPPER_CASE (CLMETHOD1, CDMETHOD)


ILNAME = LEN_TRIM (CDNAME)

IF (ALLOCATED (CLNAMES)) THEN
  

  ! Try previous match first

  IF ((1 <= IDX) .AND. (IDX <= SIZE (CLNAMES))) THEN
    IF (CLMETHODS (IDX)(1:1) /= '#') THEN
      IF (EQUAL (CDNAME, ILNAME, CLNAMES (IDX), ILNAMES (IDX))) THEN
        CALL UPPER_CASE (CLMETHOD2, CLMETHODS (IDX))
        FXTRAN_ACDC_LPARALLELMETHOD = TRIM (CLMETHOD1) == TRIM (CLMETHOD2)
        GOTO 999
      ENDIF
    ENDIF
  ENDIF

  
  IDX = -1

  DO I = 1, SIZE (CLNAMES)
    IF (CLMETHODS (I)(1:1) /= '#') THEN
      IF (EQUAL (CDNAME, ILNAME, CLNAMES (I), ILNAMES (I))) THEN
        CALL UPPER_CASE (CLMETHOD2, CLMETHODS (I))
        FXTRAN_ACDC_LPARALLELMETHOD = TRIM (CLMETHOD1) == TRIM (CLMETHOD2)
        IDX = I
        GOTO 999
      ENDIF
    ENDIF
  ENDDO
ENDIF

FXTRAN_ACDC_LPARALLELMETHOD = (CLMETHOD1 == "OPENMP") .OR. (CLMETHOD1 == "OPENMPMETHOD")

999 CONTINUE

IF (LLVERBOSE .AND. FXTRAN_ACDC_LPARALLELMETHOD) THEN
  IF (IDX > 0) THEN
    WRITE (0, '(A32," ",A)') CLMETHODS (IDX), TRIM (CLNAMES (IDX))
  ELSE
    WRITE (0, '(A32," ",A)') CLMETHOD1, TRIM (CDNAME)
    CALL FLUSH(0)
  ENDIF
ENDIF

END FUNCTION

LOGICAL FUNCTION FXTRAN_ACDC_LSYNCHOST (CDNAME) 

IMPLICIT NONE

CHARACTER (LEN=*),   INTENT (IN) :: CDNAME


CHARACTER (LEN=*), PARAMETER :: CLFILE = 'fxtran.acdc.synchost.txt'

CHARACTER (LEN=256), ALLOCATABLE, SAVE :: CLNAMES (:) 

LOGICAL, SAVE :: LLVERBOSE = .FALSE.
LOGICAL, SAVE :: LLINIT = .FALSE.

INTEGER :: ICOUNT, IERR, I
CHARACTER (LEN=16) :: CLENV

FXTRAN_ACDC_LSYNCHOST = .FALSE.

IF (.NOT. LLINIT) THEN

  CALL COUNTLINES (ICOUNT, CLFILE, IERR)
  CALL GETENV ('FXTRAN_ACDC_SYNCHOST_VERBOSE', CLENV)
  LLVERBOSE = TRIM (CLENV) /= '' .AND. TRIM (CLENV) /= '0' 

  IF (IERR == 0) THEN

    ALLOCATE (CLNAMES (ICOUNT))
    OPEN (77, FILE=CLFILE, FORM='FORMATTED')
    DO I = 1, ICOUNT
      READ (77, *) CLNAMES (I) 
    ENDDO
    CLOSE (77)

   IF (LLVERBOSE) THEN
      WRITE (0, *) "------ "//TRIM (CLFILE)//" ------"
      DO I = 1, SIZE (CLNAMES)
        WRITE (0, '(A)') TRIM (CLNAMES (I))
      ENDDO
      WRITE (0, *) "------ "//TRIM (CLFILE)//" ------"
   ENDIF

  ENDIF

  LLINIT = .TRUE.

ENDIF

IF (ALLOCATED (CLNAMES)) THEN
  DO I = 1, SIZE (CLNAMES)
    IF ((TRIM (CDNAME) == TRIM (CLNAMES (I))) .AND. (CLNAMES (I)(1:1) /= '#')) THEN
      FXTRAN_ACDC_LSYNCHOST = .TRUE.
      WRITE (0, '(A32," ",A)') "SYNCHOST", TRIM (CLNAMES (I))
      CALL FLUSH(0)
      RETURN
    ENDIF
  ENDDO
ENDIF

END FUNCTION


LOGICAL FUNCTION EQUAL (CDSTR1, KLEN1, CDSTR2, KLEN2)

CHARACTER (LEN=*) :: CDSTR1, CDSTR2
INTEGER :: KLEN1, KLEN2

INTEGER :: IC
CHARACTER :: C1, C2
INTEGER*1 :: IC1, IC2

EQUAL = .TRUE.

IF (KLEN1 /= KLEN2) THEN
  EQUAL = .FALSE.
  RETURN
ENDIF

DO IC = 1, KLEN1
  C1 = CDSTR1 (IC:IC)
  C2 = CDSTR2 (IC:IC)

  IC1 = ICHAR (C1)
  IC2 = ICHAR (C2)

  IF ((97 <= IC1) .AND. (IC1 <= 122)) IC1 = IC1 + 32
  IF ((97 <= IC2) .AND. (IC2 <= 122)) IC2 = IC2 + 32

  IF (IC1 /= IC2) THEN
    EQUAL = .FALSE.
    RETURN
  ENDIF
  
ENDDO

END FUNCTION

ELEMENTAL SUBROUTINE UPPER_CASE(OUS,INS)
IMPLICIT NONE
! CONVERT A WORD TO UPPER CASE
CHARACTER (LEN=*) , INTENT(OUT) :: OUS 
CHARACTER (LEN=*) , INTENT(IN) :: INS 
INTEGER :: I,IC,NLEN
NLEN = LEN(INS)
OUS = ''
DO I=1,NLEN
   IC = ICHAR(INS(I:I))
   IF (IC >= 97 .AND. IC < 122) THEN
     OUS(I:I) = CHAR(IC-32)
   ELSE
     OUS(I:I) = INS(I:I)
   ENDIF
END DO
END SUBROUTINE UPPER_CASE

SUBROUTINE COUNTLINES( NLINES, F, ERR )
IMPLICIT NONE
INTEGER, INTENT(OUT) :: NLINES
CHARACTER*(*), INTENT(IN) :: F
INTEGER, INTENT(OUT) :: ERR 
CHARACTER*32 :: STR 


ERR = 0

NLINES = 0 
OPEN( 77, FILE = F, ERR = 888 )

DO
  READ( 77, *, ERR = 888, END = 777 ) STR 
  NLINES = NLINES + 1 
ENDDO

777 CONTINUE

CLOSE( 77 )

RETURN
888 CONTINUE
  ERR = 1
END SUBROUTINE COUNTLINES

END MODULE


