#!/usr/bin/env perl 

=head1 NAME

fxtran-makemaker

=head1 SYNOPSIS

  $ cd compile.gpu_nvhpc_d
  $ fxtran-makemaker --SRC ../src

=head1 DESCRIPTION

C<fxtran-makemaker> is a simple C<Makefile> generator for external test
cases build with C<fxtran-f90>. 

When invoked, C<fxtran-makemaker> will:

=over 4

=item

Generate include files for subroutines.

=item

Scan source code and detect dependencies.

=item

Write a C<Makefile> to compile the code.

=back

The user is expected to provide a file named C<Makefile.inc> which contains
the compiler name and options.

=head1 OPTIONS

=over 4

=item --SRC

Path to directory containing source code and F<fxtran.conf> file.

=item --assume-generated-util-modules

If this option is passed, then do not look for util_*_mod.F90 dependencies
and assume these will be generated by the build process.

=back

=head1 SEE ALSO

make

=head1 AUTHOR

philippe.marguinaud@meteo.fr

=head1 COPYRIGHT

Meteo-France 2025

=cut

use warnings;

use strict;

use Getopt::Long;
use FileHandle;
use File::stat;
use File::Spec;
use File::Basename;
use List::MoreUtils qw (uniq);
use Data::Dumper;
use Cwd;

use FindBin qw ($Bin);
use lib "$Bin/../lib";

use Fxtran::Common;
use Fxtran;
use Fxtran::Interface;
use Fxtran::PATH;

my %opts = qw (out Makefile include Makefile.inc SRC . fxtran-extern 1);
my @opts_f = qw (assume-generated-util-modules fxtran-extern help);
my @opts_s = qw (out include SRC);

&GetOptions
(
  (map { ("$_!", \$opts{$_}) } @opts_f),
  (map { ("$_=s", \$opts{$_}) } @opts_s),
);

if ($opts{help})
  {
    print "Usage: ", &basename ($0), "\n";
    print map ({ "  --$_\n" } @opts_f);
    print map ({ "  --$_=s\n" } @opts_s);
    exit (0);
  }

$opts{include} = [split (m/,/o, $opts{include})];

my @sys = qw (NVTX OMP_LIB CUDAFOR IEEE_ARITHMETIC ISO_C_BINDING OPENACC ECCODES CUBLAS ISO_FORTRAN_ENV);
my @extern_mod = qw (YOMHOOK MPL_MODULE PARKIND1 OML_MOD EC_LUN MPL_MPIF MPL_MODULE MPL_BARRIER_MOD FIELD_MODULE 
                     FIELD_FACTORY_MODULE FIELD_ACCESS_MODULE STACK_MOD);
my @extern_inc = qw (setup_trans.h setup_trans0.h inv_trans.h gath_grid.h gath_spec.h dist_spec.h abor1.intfb.h stack.h);

for my $mod (@extern_mod)
  {
    next if (-f $opts{SRC} . '/' . lc ($mod) . '.F90');
    push @sys, $mod;
  }

my %slurp;

sub slurp
{
  my $f = shift;
  unless ($slurp{$f})
    {
      $slurp{$f} = do { local $/ = undef; my $fh = 'FileHandle'->new ("<$f"); $fh or die ("Cannot open `$f' for reading\n"); <$fh> };
    }

  return $slurp{$f};
}

my (%deps, %mod2obj, %notfound);

sub deps
{
  my $f = shift;

  my %sys = map { ($_, 1) } @sys;

  my %extern_inc = map { ($_, 1) } @extern_inc;

  unless ($deps{$f})
    {
      my $code = &slurp ($f);

      my ($sub) = ($code =~ m/SUBMODULE\s*\(s*(\w+)\s*\)/goms); $sub = uc ($sub) if ($sub);

      my @inc = ($code =~ m/\n\s*#include\s+"(.*?)"/goms);
      @inc = grep { ! $extern_inc{$_} } @inc;
      @inc = grep { ! m/^fxtran_acdc_/o } @inc if ($opts{'fxtran-extern'});
      
      my @use = map { uc ($_) } 
                (($code =~ m/\n\s*use\s+(\w+)/gomis), 
                 ($code =~ m/\n\s*submodule\*s\(\s*(\w+)\s*\)/gomis));

      push @use, $sub if ($sub);

      @use = sort grep { ! $sys{uc ($_)} } @use;  
      @use = sort grep { ! m/^FXTRAN_ACDC_/o } @use if ($opts{'fxtran-extern'});

      my @mod = map { lc ($_) . '.mod' } @use; 

      @mod = grep { ! m/^util_\w+_mod\.mod$/o } @mod if ($opts{'assume-generated-util-modules'});

      $deps{$f} = [@mod, @inc];

      for my $dep (@{ $deps{$f} })
        {
          if ($dep =~ s/\.h$/.ok/o)
            {
            }
          elsif ($dep =~ m/\.mod$/o)
            {
              if ($mod2obj{$dep})
                {
                  $dep = $mod2obj{$dep};
                }
              else
                {
                  push @{ $notfound{$f} }, $dep;
                }
            }
        }

      @{ $deps{$f} } = &uniq (@{ $deps{$f} });

   }

  return @{ $deps{$f} };
}

sub mods
{
  my $f = shift;
  my $code = &slurp ($f);
  my @mods = ($code =~ m/^\s*MODULE\s+(\w+)\s*$/igom);
  @mods = map { lc ($_) . '.mod' } @mods;
  return @mods;
}

sub obj
{
  (my $f = &basename ($_[0])) =~ s/\.(?:F90|F|c)$//o;
  return "\$(BUILD)/$f.o";
}

sub exe
{
  (my $f = &basename ($_[0])) =~ s/\.(?:F90|F|c)$//o;
  return "\$(BUILD)/$f.x";
}

sub ok
{
  (my $f = &basename ($_[0])) =~ s/\.(?:h)$//o;
  return "\$(BUILD)/$f.ok";
}

my %kind;

sub kind
{
  my $f = shift;
  unless ($kind{$f})
    {
      my $code = &slurp ($f);
      my @code = split (m/\n/o, $code);
      for (@code)
        {
          s/^#.*//o;
          s/^\s*!.*//o;
        }
      @code = grep { length ($_) } @code;
      $code = join ("\n", @code, "");
      my ($kind) = ($code =~ m/^\s*(PROGRAM|SUBROUTINE|MODULE|FUNCTION)/igoms);
      $kind or die &Dumper ([$f, $code]);
      $kind{$f} = uc ($kind);
    }

  return $kind{$f};
}

sub newer
{
  my ($f1, $f2) = @_;
  return unless ((-f $f1) && (-f $f2));
  use File::stat;
  my $st1 = stat ($f1);
  my $st2 = stat ($f2);
  return $st1->mtime > $st2->mtime;
}

for my $fypp (<$opts{SRC}/*.fypp>)
  {
    my $code = &slurp ($fypp);
    my @field_config = ($code =~ m/field_config/goms ? qw (-m -field_config) : ());
    (my $F90 = &basename ($fypp)) =~ s/\.fypp/.F90/o;
    next if (&newer ($F90, $fypp));
    system (qw (fypp -m os -M . -m yaml), @field_config, "./$fypp", $F90) and die ($fypp);
  }

my @F90 = map { 'File::Spec'->rel2abs ($_) } <$opts{SRC}/*.F90>;

my $fh = 'FileHandle'->new (">$opts{out}");

$fh->print (<< "EOF");

ifeq (\$(SRC), )
SRC=$opts{SRC}
endif

ifeq (\$(BUILD), )
BUILD=.
endif

all: exe

EOF

$fh->print (join ("\n", map ({ "include $_"  } @{ $opts{include} }), '', ''));


my (@obj, @prg);

for my $F90 (@F90)
  {
    my $obj = &obj ($F90);
    my $kind = &kind ($F90);
    if ($kind eq 'MODULE')
      {
        my @mod = &mods ($F90);
        for my $mod (@mod)
          {
            $mod2obj{$mod} = $obj;
          }
      }
  }

for my $F90 (@F90)
  {
    my $kind = &kind ($F90);

    if ($kind eq 'SUBROUTINE')
      {
        (my $base = &basename ($F90)) =~ s/\.F90$//io;

        next if (-f "$opts{SRC}/$base.h");

        my $intfb = "$base.intfb.h";

        if ((! -f $intfb) || &newer ($F90, $intfb))
          {
            my @cmd = ('fxtran-f90', '--method', 'interface', 
                       (-f "$opts{SRC}/fxtran.conf" ?  ('--config', "$opts{SRC}/fxtran.conf") : ()),
                       '--dir', '.', '--dryrun', '--tmp', '.', '--', 'f90', '-c', $F90);
            system (@cmd)
              and die ("Command `@cmd' failed");
          }

        my $ok = &ok ($intfb);
        my @deps = &deps ($intfb);
        $fh->print (<< "EOF");
$ok: \$(BUILD)/$intfb @deps
	touch $ok

EOF
      }
    elsif ($kind eq 'PROGRAM')
      {
        push @prg, $F90;
      }
  }


for my $H (grep { ! m/\.intfb\.h$/o } <$opts{SRC}/*.h>)
  {
    my $ok = &ok ($H);
    my @deps = &deps ($H);
    my $h = &basename ($H);
    $fh->print (<< "EOF");
$ok: \$(SRC)/$h @deps
	touch $ok

EOF
  }



my @subobj;

for my $F90 (@F90)
  {
    my @deps = &deps ($F90);
    my @mods = &mods ($F90);
    my $kind = &kind ($F90);
    my $obj = &obj ($F90);
    my $f90 = &basename ($F90);

    if ($kind eq 'MODULE')
      {
        @deps = grep { ($_ ne $obj) } @deps;
      }

    $fh->print (<< "EOF");
$obj: \$(BOOT) \$(SRC)/$f90 @deps
	\$(FC) -o $obj -c \$(SRC)/$f90

EOF

    push @obj, $obj if ($kind ne 'PROGRAM');

    push @subobj, $obj if ($kind ne 'MODULE');
  }

if (%notfound)
  {
    print STDERR "The following modules were not found;\n";
    for my $f (sort keys %notfound)
      {
        my @mod = @{ $notfound{$f} };
        s/\.mod$/.F90/o for (@mod);
        print STDERR " - $f\n";
        print STDERR  '   ' . join (" ", @mod) . "\n";
      }
    die "\n";
  }

for my $C (<$opts{SRC}/*.c>)
  {
    my $obj = &obj ($C);
    my $c = &basename ($C);
    $fh->print (<< "EOF");
$obj: \$(BOOT) \$(SRC)/$c
	\$(CC) -o $obj -c \$(SRC)/$c
EOF
    push @obj, $obj;
    push @subobj, $obj;
  }

my @exe;

for my $prg (@prg)
  {
    my $exe = &exe ($prg);
    my $obj = &obj ($prg);
    $fh->print (<< "EOF");
$exe: \$(BOOT) $obj @obj
	\$(FC) -o $exe $obj @obj \$(LIBS)

EOF
    push @exe, $exe;
  }


$fh->print (<< "EOF");

exe: @exe

subclean:
	\\rm -f @subobj

clean: 
	\\rm -f \$(BUILD)/*.o \$(BUILD)/*.xml \$(BUILD)/*.a \$(BUILD)/*.x \$(BUILD)/*.mod \$(BUILD)/*.optrpt \$(BUILD)/*.smod \$(BUILD)/*.ok \$(BUILD)/*.optrpt

tidy:
	\\rm -f \$(BUILD)/*.xml \$(BUILD)/*.optrpt
EOF

