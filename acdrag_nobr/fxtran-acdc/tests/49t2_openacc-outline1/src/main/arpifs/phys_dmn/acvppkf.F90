!OPTIONS XOPT(NOEVAL)
!-----------------------------------------------------------------
SUBROUTINE ACVPPKF(YDCST, YDML_PHY_MF, YDCPG_BNDS, YDCPG_OPTS, KTDIA, PAPRSF, PAPHIF, PDELP,  PR, PT, &
& PQ, PQL, PQI, PU, PV, PCP, PTKE, PDIFCQ, PDIFCS, PFCCQL, PFCCQN, PPRODTH, KNLAB,  PQCPP, PNEBPP,    &
& KNND)

!$ACDC outline1    


!-----------------------------------------------------------------

!  Authors  : E. Bazile and P. Bechtold  (CNRM/GMAP et L.A.)

!-----------------------------------------------------------------

!  Modified : 
!  05/2002    phased with CONVECTION call for IFS/ECMWF 
!            (routine cucalln.F90 calling both Tiedtke convection scheme
!             and present scheme)
!             ouput of present scheme (updraft QL and QV) provides also
!             necessary parameters for Tiedtke prognostic cloud scheme
!  03/2002  P. Marquet.  new  ZFHMLTS, ZFHEVPP in CPFHPRS (for Lopez)
!  03/2002  P. Marquet.  new  LKFDEEP, LKFSHAL
!  03/2002  P. Marquet.  "call deep_convection" 
!                      > "call convection" (deep + shallow)
!  09/2006  E. Bazile : Appel de la routine de shallow convection d'AROME
!                       uniquement
!  04/2008  E. Bazile : calcul du terme de production thermique PPROTH
!  10/2008  Y. Bouteloup & F. Bouyssel : Correction of bugs in initialization
!  07/2009  E. Bazile : TKE en entree de KFB et W fct de W_conv
!  K. Yessad (Jul 2009): remove CDLOCK + some cleanings
!  10/2009  F. Bouyssel : Limitation on maximal TKE value
!  02/2010  E. Bazile : Correction for W without TKE scheme.
!  04/2010  F. Bouyssel : Bug correction on KNLAB computation
!  09/2010  O. Spaniel : Bug correction in expression SQRT(MIN)
!  04/2011  F. Bouyssel : Correction of a jlon loop (kidia,kfdia)
!  12/2012  E. Bazile   : Modif of W_turb and qc and cc fct of mass flux.
!     R. El Khatib 22-Jun-2022 A contribution to simplify phasing after the refactoring of YOMCLI/YOMCST/YOETHF.

!  Peter.Bechtold@ecmwf.int

! Sequence de  routines :
! aplpar > acvppkf > convection_shal

! iv)  Momentum transport:
!      Option LLUVTRANS: c'est possible d'utiliser maintenant
!           mais pas encore bien teste. Donc par defaut mettre
!           LLUVTRANS=.FALSE.

! vi)   Traceurs passifs - chimie: 
!      Cette partie est utilisee uniquement dans MOCAGE et dans MESONH
!      Si on ne veut pas de transport de traceurs (ex. Ozone,CO) dans 
!      ARPEGE/ECMWF IFS, mettre tout siplement OCHTRANS=FALSE et KCH1=0 
!      (nombre de traceurs). PCH1 (traceur) et PCH1TEN (tendance 
!      convective du traceur) ont alors les dimensions
!      (KLON,KLEV,KCH1=0) qui ne prennent pas de place.

!-----------------------------------------------------------------

USE MODEL_PHYSICS_MF_MOD, ONLY : MODEL_PHYSICS_MF_TYPE
USE PARKIND1            , ONLY : JPIM, JPRB
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK, JPHOOK

USE YOMCST              , ONLY : TCST
USE YOMLSFORC           , ONLY : LMUSCLFA, NMUSCLFA
USE MODD_CONVPAR_SHAL   , ONLY : CONVPAR_SHAL

USE MODD_DIMPHYEX       , ONLY : DIMPHYEX_T
USE CPG_OPTS_TYPE_MOD   , ONLY : CPG_BNDS_TYPE, CPG_OPTS_TYPE

USE MODI_SHALLOW_CONVECTION_PART1,        ONLY : SHALLOW_CONVECTION_PART1
USE MODI_SHALLOW_CONVECTION_PART2,        ONLY : SHALLOW_CONVECTION_PART2
USE MODI_SHALLOW_CONVECTION_PART2_SELECT, ONLY : SHALLOW_CONVECTION_PART2_SELECT


!-----------------------------------------------------------------

IMPLICIT NONE

TYPE(TCST)                  ,INTENT(IN)     :: YDCST
TYPE(MODEL_PHYSICS_MF_TYPE) ,INTENT(IN)     :: YDML_PHY_MF
TYPE(CPG_BNDS_TYPE)         ,INTENT(IN)     :: YDCPG_BNDS
TYPE(CPG_OPTS_TYPE)         ,INTENT(IN)     :: YDCPG_OPTS
INTEGER(KIND=JPIM)          ,INTENT(IN)     :: KTDIA 
REAL(KIND=JPRB)             ,INTENT(IN)     :: PAPRSF(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(IN)     :: PAPHIF(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(IN)     :: PDELP(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(IN)     :: PR(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(IN)     :: PT(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(IN)     :: PQ(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(IN)     :: PQL(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(IN)     :: PQI(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(IN)     :: PU(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(IN)     :: PV(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(IN)     :: PCP(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB)             ,INTENT(IN)     :: PTKE(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB)             ,INTENT(INOUT)  :: PDIFCQ(YDCPG_OPTS%KLON,0:YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(INOUT)  :: PDIFCS(YDCPG_OPTS%KLON,0:YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(INOUT)  :: PFCCQL(YDCPG_OPTS%KLON,0:YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(INOUT)  :: PFCCQN(YDCPG_OPTS%KLON,0:YDCPG_OPTS%KFLEVG) 
REAL(KIND=JPRB)             ,INTENT(INOUT)  :: PPRODTH(YDCPG_OPTS%KLON,0:YDCPG_OPTS%KFLEVG)
INTEGER(KIND=JPIM)          ,INTENT(OUT)    :: KNLAB(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB)             ,INTENT(INOUT)  :: PQCPP(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB)             ,INTENT(INOUT)  :: PNEBPP(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) 
INTEGER(KIND=JPIM)          ,INTENT(OUT)    :: KNND(YDCPG_OPTS%KLON) 

!-----------------------------------------------------------------

#include "fcttrm.func.h"
#include "wrscmr.intfb.h"

INTEGER(KIND=JPIM), PARAMETER :: I_KCH1 = 0

LOGICAL :: LLREFRESH_ALL, LLDOWN, LLUVTRANS, LLOCHTRANS, LLCONDWT


REAL(KIND=JPRB) :: ZDTCONV, ZVMD, ZWMD, ZSMD, ZTDCP, ZEPS, ZDQCDT, ZDTLDT

INTEGER(KIND=JPIM) :: JLON, JLEV, I_KBDIA, IKICE

INTEGER(KIND=JPIM) :: I_KCOUNT(YDCPG_OPTS%KLON)
INTEGER(KIND=JPIM) :: I_KCLTOP(YDCPG_OPTS%KLON)
INTEGER(KIND=JPIM) :: I_KCLBAS(YDCPG_OPTS%KLON)

REAL(KIND=JPRB) :: ZCAPE(YDCPG_OPTS%KLON)

REAL(KIND=JPRB) :: ZW     (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZDTDT  (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZDQVDT (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZDQLDT (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZDQIDT (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZDUDT  (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZDVDT  (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZUMF   (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZUQV   (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZUQL   (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZDPSG  (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZLV    (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZLS    (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZQC    (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZBETA  (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL(KIND=JPRB) :: ZAPHIF (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)

REAL(KIND=JPRB) :: ZTHETA (YDCPG_OPTS%KLON,0:YDCPG_OPTS%KFLEVG+1)
REAL(KIND=JPRB) :: ZRHO   (YDCPG_OPTS%KLON,0:YDCPG_OPTS%KFLEVG+1)

REAL(KIND=JPRB) :: ZCH1   (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG,I_KCH1)
REAL(KIND=JPRB) :: ZCH1TEN(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG,I_KCH1)
REAL(KIND=JPRB) :: ZTKECLS(YDCPG_OPTS%KLON)
REAL(KIND=JPRB) :: ZUMFMAX(YDCPG_OPTS%KLON)

INTEGER  :: JKP, JN  ! loop index
! Local arrays (upside/down) necessary for change of ECMWF arrays to convection arrays
REAL(KIND=JPRB) :: ZT     (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! grid scale T at time t  (K)
REAL(KIND=JPRB) :: ZRV    (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! grid scale water vapor  (kg/kg)
REAL(KIND=JPRB) :: ZRC    (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! grid scale r_c mixing ratio (kg/kg)
REAL(KIND=JPRB) :: ZRI    (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! grid scale r_i mixing ratio (kg/kg)
REAL(KIND=JPRB) :: ZU     (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! grid scale horiz. wind u (m/s)
REAL(KIND=JPRB) :: ZV     (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! grid scale horiz. wind v (m/s)
REAL(KIND=JPRB) :: ZZW    (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! grid scale vertical velocity (m/s)
REAL(KIND=JPRB) :: ZPABS  (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! grid scale pressure (Pa)
REAL(KIND=JPRB) :: ZZZ    (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! height of model layer (m)
                                                             
REAL(KIND=JPRB) :: ZTTEN  (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! convective temperat. tendency (K/s)
REAL(KIND=JPRB) :: ZRVTEN (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! convective r_v tendency (1/s)
REAL(KIND=JPRB) :: ZRCTEN (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! convective r_c tendency (1/s)
REAL(KIND=JPRB) :: ZRITEN (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! convective r_i tendency (1/s)
REAL(KIND=JPRB) :: ZUTEN  (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! convective u tendency (m/s^2)
REAL(KIND=JPRB) :: ZVTEN  (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! convective m tendency (m/s^2)
REAL(KIND=JPRB) :: ZZUMF  (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! updraft mass flux   (kg/s m2)
REAL(KIND=JPRB) :: ZURV   (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! water vapor in updrafts (kg/kg)
REAL(KIND=JPRB) :: ZURCI  (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG) ! total condensate in updrafts (kg/kg)
INTEGER(KIND=JPIM) :: ICLTOP (YDCPG_OPTS%KLON)    ! cloud top level (number of model level)
INTEGER(KIND=JPIM) :: ICLBAS (YDCPG_OPTS%KLON)    ! cloud base level(number of model level)
REAL(KIND=JPRB) :: ZSHAL_ZCH1     (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG,I_KCH1) ! grid scale chemical species
REAL(KIND=JPRB) :: ZSHAL_ZCH1TEN  (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG,I_KCH1) ! chemical convective tendency
! special for shallow convection
REAL(KIND=JPRB) :: ZSHAL_ZCH1TENS (YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG,I_KCH1)
INTEGER(KIND=JPIM) :: ICLBASS (YDCPG_OPTS%KLON), ICLTOPS (YDCPG_OPTS%KLON)

! Declarations of local fixed memory variables :
REAL (KIND=JPRB) :: ZRDOCP ! R_d/C_p

REAL (KIND=JPRB) :: ZTHT(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL (KIND=JPRB) :: ZSTHV(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)
REAL (KIND=JPRB) :: ZSTHES(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)  ! grid scale theta, theta_v
! Declarations of local allocatable  variables :
INTEGER (KIND=JPIM) :: ISDPL(YDCPG_OPTS%KLON)   ! index for parcel departure level
INTEGER (KIND=JPIM) :: ISPBL(YDCPG_OPTS%KLON)   ! index for source layer top
INTEGER (KIND=JPIM) :: ISLCL(YDCPG_OPTS%KLON)   ! index for lifting condensation level
REAL (KIND=JPRB) :: ZSTHLCL(YDCPG_OPTS%KLON) ! updraft theta at LCL/L
REAL (KIND=JPRB) :: ZSTLCL(YDCPG_OPTS%KLON)  ! updraft temp. at LCL
REAL (KIND=JPRB) :: ZSRVLCL(YDCPG_OPTS%KLON) ! updraft rv at LCL
REAL (KIND=JPRB) :: ZSWLCL(YDCPG_OPTS%KLON)  ! updraft w at LCL
REAL (KIND=JPRB) :: ZSZLCL(YDCPG_OPTS%KLON)  ! LCL height
REAL (KIND=JPRB) :: ZSTHVELCL(YDCPG_OPTS%KLON)! envir. theta_v at LCL

LOGICAL :: LLTRIG1(YDCPG_OPTS%KLON)  ! logical mask for convection

TYPE(DIMPHYEX_T)   :: D

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('ACVPPKF',0,ZHOOK_HANDLE)
ASSOCIATE(RKFBNBX=>YDML_PHY_MF%YRPHY0%RKFBNBX, RKFBTAU=>YDML_PHY_MF%YRPHY0%RKFBTAU, RQLCR=>YDML_PHY_MF%YRPHY0%RQLCR, &
 & RPRTH=>YDML_PHY_MF%YRPHY0%RPRTH, ECTMIN=>YDML_PHY_MF%YRPHY0%ECTMIN, AECLS4=>YDML_PHY_MF%YRPHY0%AECLS4, &
 & TSPHY=>YDML_PHY_MF%YRPHY2%TSPHY, &
 & LSMOOTH=>YDML_PHY_MF%YRCVMNH%LSMOOTH, &
 & OTADJS=>YDML_PHY_MF%YRCVMNH%OTADJS, &
 & LSETTADJ=>YDML_PHY_MF%YRCVMNH%LSETTADJ, &
 & RATM=>YDCST%RATM, RCPD=>YDCST%RCPD, RCPV=>YDCST%RCPV, RCS=>YDCST%RCS, RCW=>YDCST%RCW, &
 & RG=>YDCST%RG, RKAPPA=>YDCST%RKAPPA, RLSZER=>YDCST%RLSZER, RLVZER=>YDCST%RLVZER, &
 & LECT=>YDML_PHY_MF%YRPHY%LECT, LCVDD=>YDML_PHY_MF%YRPHY%LCVDD, &
 & YDCVPEXT=>YDML_PHY_MF%YRCVMNH%YRCVPEXT, &
 & YDCVP_SHAL=>YDML_PHY_MF%YRCVMNH%YRCVP_SHAL, &
 & YDCST_MNH=>YDML_PHY_MF%YRCVMNH%YRCST_MNH, &
 & YDNSV=>YDML_PHY_MF%YRCVMNH%YRNSV, &
 & YDCONVPAR=>YDML_PHY_MF%YRCVMNH%YRCONVPAR)
!-----------------------------------------------------------------

!$ACDC SERIAL {

D%NIT = YDCPG_OPTS%KLON
D%NIB = YDCPG_BNDS%KIDIA
D%NIE = YDCPG_BNDS%KFDIA
D%NKT = YDCPG_OPTS%KFLEVG

ZVMD=RCPV-RCPD
ZWMD=RCW-RCPD
ZSMD=RCS-RCPD

I_KBDIA=1
IKICE=1
LLREFRESH_ALL=.TRUE.
LLDOWN=LCVDD
LLUVTRANS=.FALSE. ! not yet well tested but possible to use
LLOCHTRANS=.FALSE.
ZDTCONV=TSPHY
ZEPS=1.E-12_JPRB

ZRDOCP = YDML_PHY_MF%YRCVMNH%YRCST_MNH%XRD / YDML_PHY_MF%YRCVMNH%YRCST_MNH%XCPD

LLCONDWT=.FALSE.

!$ACDC }

!$ACDC PARALLEL,TARGET=OpenMP/OpenMPSingleColumn/OpenACCSingleColumn,NAME=PART0 {

ZUMFMAX(:)=1.E-12_JPRB
ZW(:,:)=0.0_JPRB
ZTKECLS(:)=0.0_JPRB
IF (LECT) THEN
  DO JLEV=1,YDCPG_OPTS%KFLEVG
    DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
      ZW(JLON,JLEV) = SQRT(MIN(3.0_JPRB,MAX(ECTMIN,PTKE(JLON,JLEV)))/AECLS4)
    ENDDO
  ENDDO
  DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
     ZTKECLS(JLON)=PTKE(JLON,YDCPG_OPTS%KFLEVG) 
  ENDDO
ENDIF
DO JLEV=1,YDCPG_OPTS%KFLEVG
  DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
    ZDPSG (JLON,JLEV) = PDELP(JLON,JLEV)/RG
    ZAPHIF(JLON,JLEV) = PAPHIF(JLON,JLEV)/RG
  ENDDO
ENDDO

DO JLEV=1,YDCPG_OPTS%KFLEVG
  DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
    ZDTDT (JLON,JLEV) = 0.0_JPRB
    ZDQVDT(JLON,JLEV) = 0.0_JPRB
    ZDQLDT(JLON,JLEV) = 0.0_JPRB
    ZDQIDT(JLON,JLEV) = 0.0_JPRB
    ZDUDT (JLON,JLEV) = 0.0_JPRB
    ZDVDT (JLON,JLEV) = 0.0_JPRB
    ZUMF  (JLON,JLEV) = 0.0_JPRB
    ZUQV  (JLON,JLEV) = 0.0_JPRB
    ZUQL  (JLON,JLEV) = 0.0_JPRB
    ZLV   (JLON,JLEV) = FOLH(PT(JLON,JLEV),0.0_JPRB)
    ZLS   (JLON,JLEV) = FOLH(PT(JLON,JLEV),1.0_JPRB)
    ZQC   (JLON,JLEV) = PQL(JLON,JLEV)+PQI(JLON,JLEV)
  ENDDO
ENDDO

DO JLON=1,YDCPG_BNDS%KFDIA
  I_KCOUNT(JLON) = 0
  ZCAPE   (JLON) = 0.0_JPRB
ENDDO

I_KCLTOP(:)  = 1 ! set default value when no convection
I_KCLBAS(:)  = 1 ! can be changed  depending on user
ICLTOP(:)  = 1
ICLBAS(:)  = 1
ICLTOPS(:) = 1
ICLBASS(:) = 1

!*       2.   Flip arrays upside-down as  first vertical level in convection is 1
!             --------------------------------------------------------------------

DO JLEV = 1, YDCPG_OPTS%KFLEVG
  JKP = YDCPG_OPTS%KFLEVG - JLEV + 1
  DO JLON = YDCPG_BNDS%KIDIA, YDCPG_BNDS%KFDIA
    ZPABS(JLON,JKP) = PAPRSF(JLON,JLEV)
    ZZZ(JLON,JKP)   = ZAPHIF(JLON,JLEV)
    ZT(JLON,JKP)    = PT(JLON,JLEV)
    ZRV(JLON,JKP)   = PQ(JLON,JLEV) / ( 1.0 - PQ(JLON,JLEV) ) ! transform specific humidity
    ZRC(JLON,JKP)   = PQL(JLON,JLEV) / ( 1.0 - PQL(JLON,JLEV) ) ! in mixing ratio
    ZRI(JLON,JKP)   = PQI(JLON,JLEV) / ( 1.0 - PQI(JLON,JLEV) )
    ZU(JLON,JKP)    = PU(JLON,JLEV)
    ZV(JLON,JKP)    = PV(JLON,JLEV)
    ZZW(JLON,JKP)   = ZW(JLON,JLEV)
  ENDDO
ENDDO

IF ( LLOCHTRANS ) THEN
  DO JLEV = 1, YDCPG_OPTS%KFLEVG
    JKP = YDCPG_OPTS%KFLEVG - JLEV + 1
    DO JN = 1, I_KCH1
      DO JLON = YDCPG_BNDS%KIDIA, YDCPG_BNDS%KFDIA
        ZSHAL_ZCH1(JLON,JKP,JN) = ZCH1(JLON,JLEV,JN)
      ENDDO
    ENDDO
  ENDDO
ENDIF

I_KCOUNT(:)   =0
ZTTEN(:,:)    =0.0
ZRVTEN(:,:)   =0.0
ZRCTEN(:,:)   =0.0
ZRITEN(:,:)   =0.0
ZUTEN(:,:)    =0.0
ZVTEN(:,:)    =0.0
ZZUMF(:,:)    =0.0
ZURV(:,:)     =0.0
ZURCI(:,:)    =0.0
ZSHAL_ZCH1TEN(:,:,:)=0.0
ZCAPE(:)      =0.0

!$ACDC }

!*       4.b  Call shallow convection routine
!             -------------------------------

!$ACDC PARALLEL,TARGET=OpenMP/OpenMPSingleColumn/OpenACCSingleColumn,NAME=PART1,STYLE=MesoNH {

CALL SHALLOW_CONVECTION_PART1   (YDCVPEXT, YDCVP_SHAL, YDCST_MNH, D, YDNSV, YDCONVPAR,         &
& I_KBDIA, KTDIA, IKICE, LSETTADJ, OTADJS, ZPABS, ZZZ, ZTKECLS, ZT, ZRV, ZRC, ZRI, ZZW, ZTTEN, ZRVTEN,  &
& ZRCTEN, ZRITEN, ICLTOPS, ICLBASS, ZZUMF, LLOCHTRANS, I_KCH1, ZSHAL_ZCH1, ZSHAL_ZCH1TENS,              &
& ZTHT, ZSTHV, ZSTHES, ISDPL, ISPBL, ISLCL, ZSTHLCL, ZSTLCL, ZSRVLCL, ZSWLCL, ZSZLCL, ZSTHVELCL, LLTRIG1)

!$ACDC }


!$ACDC PARALLEL, &
!$ACDC   TARGET=OpenMP/OpenMPSingleColumn/OpenACCSingleColumn, &
!$ACDC   NAME=PART2, STYLE=MesoNH, FILTER=LLTRIG1, &
!$ACDC   SUBROUTINE=SHALLOW_CONVECTION_PART2_SELECT {

   CALL SHALLOW_CONVECTION_PART2_SELECT &
   & (YDCVP_SHAL, YDCVPEXT, YDCST_MNH, D, YDNSV, YDCONVPAR,                     &
   & IKICE, LSETTADJ, OTADJS, ZPABS, ZZZ, ZT, ZRV, ZRC, ZRI,                    &
   & LLOCHTRANS, I_KCH1, ZSHAL_ZCH1, ZRDOCP, ZTHT, ZSTHV, ZSTHES, ISDPL, ISPBL, &
   & ISLCL, ZSTHLCL, ZSTLCL, ZSRVLCL, ZSWLCL, ZSZLCL, ZSTHVELCL, LLTRIG1,       &
   & ZZUMF, ZTTEN, ZRVTEN, ZRCTEN, ZRITEN, ICLTOPS, ICLBASS, ZSHAL_ZCH1TENS,    &
   & COUNT(LLTRIG1(D%NIB:D%NIE)))

!$ACDC }

!$ACDC PARALLEL,TARGET=OpenMP/OpenMPSingleColumn/OpenACCSingleColumn,NAME=PART3 {

DO JLON = YDCPG_BNDS%KIDIA, YDCPG_BNDS%KFDIA
  ICLTOP(JLON)   = MAX(ICLTOP(JLON), ICLTOPS(JLON))
  ICLBAS(JLON)   = MAX(ICLBAS(JLON), ICLBASS(JLON))
ENDDO

!*       6.  Reflip arrays to ECMWF/ARPEGE vertical structure
!            change mixing ratios to sepcific humidity

DO JLEV = 1, YDCPG_OPTS%KFLEVG
  JKP = YDCPG_OPTS%KFLEVG - JLEV + 1
  DO JLON = YDCPG_BNDS%KIDIA, YDCPG_BNDS%KFDIA
    ZDTDT(JLON,JLEV)  = ZTTEN(JLON,JKP)
   ! don't transform back to specific hum, does not conserve integrals
    ZDQVDT(JLON,JLEV) = ZRVTEN(JLON,JKP) ! / ( 1.0 + ZRV(JI,JKP) ) ** 2
    ZDQLDT(JLON,JLEV) = ZRCTEN(JLON,JKP) ! / ( 1.0 + ZRC(JI,JKP) ) ** 2
    ZDQIDT(JLON,JLEV) = ZRITEN(JLON,JKP) ! / ( 1.0 + ZRI(JI,JKP) ) ** 2
    ZDUDT(JLON,JLEV)  = ZUTEN(JLON,JKP)
    ZDVDT(JLON,JLEV)  = ZVTEN(JLON,JKP)
    ZUMF(JLON,JLEV)   = ZZUMF(JLON,JKP)
    ZUQV(JLON,JLEV)   = ZURV(JLON,JKP) / ( 1.0 + ZURV(JLON,JKP) )
    ZUQL(JLON,JLEV)  = ZURCI(JLON,JKP)/ ( 1.0 + ZURCI(JLON,JKP) )
  ENDDO
ENDDO

DO JLON = YDCPG_BNDS%KIDIA, YDCPG_BNDS%KFDIA
  JLEV = ICLTOP(JLON)
  I_KCLTOP(JLON) = YDCPG_OPTS%KFLEVG - JLEV + 1
  JLEV = ICLBAS(JLON)
  I_KCLBAS(JLON) = YDCPG_OPTS%KFLEVG - JLEV + 1
  IF ( ICLTOP(JLON) == 1 ) I_KCLTOP(JLON) = 1
  IF ( ICLBAS(JLON) == 1 ) I_KCLBAS(JLON) = 1
ENDDO

IF ( LLOCHTRANS ) THEN
  DO JLEV = 1, YDCPG_OPTS%KFLEVG
    JKP = YDCPG_OPTS%KFLEVG - JLEV + 1
    DO JN = 1, I_KCH1
      DO JLON = YDCPG_BNDS%KIDIA, YDCPG_BNDS%KFDIA
        ZCH1TEN(JLON,JLEV,JN) = ZSHAL_ZCH1TEN(JLON,JKP,JN)
      ENDDO
    ENDDO
  ENDDO
ENDIF

! Calcul de la production thermique pour la TKE
PPRODTH(:,:)=0.0_JPRB
IF (RPRTH > 0._JPRB) THEN
  DO JLEV=1,YDCPG_OPTS%KFLEVG
    DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
      ZBETA (JLON,JLEV) = (RATM/PAPRSF(JLON,JLEV))**(RKAPPA)
      ZTHETA(JLON,JLEV) = PT(JLON,JLEV)*ZBETA(JLON,JLEV)
      ZRHO  (JLON,JLEV) = PAPRSF(JLON,JLEV)/(PR(JLON,JLEV)*PT(JLON,JLEV))
    ENDDO
  ENDDO
  DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
    ZTHETA(JLON,0)      = ZTHETA(JLON,1)
    ZRHO  (JLON,0)      = ZRHO  (JLON,1)
    ZTHETA(JLON,YDCPG_OPTS%KFLEVG+1) = ZTHETA(JLON,YDCPG_OPTS%KFLEVG)
    ZRHO  (JLON,YDCPG_OPTS%KFLEVG+1) = ZRHO  (JLON,YDCPG_OPTS%KFLEVG)
  ENDDO

  DO JLEV=1,YDCPG_OPTS%KFLEVG
    DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
      ZTDCP=ZVMD*ZDQVDT(JLON,JLEV)+ZWMD*ZDQLDT(JLON,JLEV)+ZSMD*ZDQIDT(JLON,JLEV)
      ZDQCDT=ZDQLDT(JLON,JLEV)+ZDQIDT(JLON,JLEV)
      ZDTLDT=ZBETA (JLON,JLEV)&
        &  * ( ZDTDT(JLON,JLEV) + ZLV(JLON,JLEV)/PCP(JLON,JLEV)&
        &    * ( ZQC(JLON,JLEV)*ZTDCP/PCP(JLON,JLEV)-ZDQCDT ) )
      PPRODTH(JLON,JLEV)=PPRODTH(JLON,JLEV-1)-ZDPSG(JLON,JLEV)*ZDTLDT
    ENDDO
  ENDDO

  DO JLEV=0,YDCPG_OPTS%KFLEVG
    DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
      PPRODTH(JLON,JLEV)=PPRODTH(JLON,JLEV)*RG*4._JPRB&
        & / ( ZRHO  (JLON,JLEV) + ZRHO  (JLON,JLEV+1) )&
        & / ( ZTHETA(JLON,JLEV) + ZTHETA(JLON,JLEV+1) )
    ENDDO
  ENDDO
ENDIF ! Fin du calcul de la production thermique pour la TKE

DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
  DO JLEV=1,YDCPG_OPTS%KFLEVG
    KNLAB(JLON,JLEV)=1-MAX(0,MIN(1,(I_KCLTOP(JLON)-JLEV)*(I_KCLBAS(JLON)-JLEV)))
  ENDDO
  KNND(JLON)=MIN(1,I_KCLTOP(JLON)-1)
ENDDO

! Calcul de la nebulosite et de l'eau condensee
IF (RKFBTAU > 0._JPRB) THEN
  DO JLEV=1,YDCPG_OPTS%KFLEVG
!DEC$ IVDEP
    DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
      ZDQCDT=MAX(0.0_JPRB,ZDQLDT(JLON,JLEV)+ZDQIDT(JLON,JLEV))
      PQCPP (JLON,JLEV)=RKFBTAU*ZDQCDT*FLOAT(KNLAB(JLON,JLEV))
      PNEBPP(JLON,JLEV)=MAX(ZEPS,MIN(RKFBNBX,PQCPP(JLON,JLEV)/RQLCR))
      ZUMFMAX(JLON)=MAX(ZUMFMAX(JLON),ZUMF(JLON,JLEV))
    ENDDO
  ENDDO
  IF (.NOT.LSMOOTH) THEN
    DO JLEV=1,YDCPG_OPTS%KFLEVG
!DEC$ IVDEP
      DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
        PQCPP (JLON,JLEV)=PQCPP(JLON,JLEV)&
         & *MIN(1.0_JPRB,ZUMF(JLON,JLEV)/ZUMFMAX(JLON))
        PNEBPP(JLON,JLEV)=MAX(ZEPS,MIN(RKFBNBX,PQCPP(JLON,JLEV)/RQLCR))
      ENDDO
    ENDDO
  ENDIF
ENDIF ! Fin du calcul de la nebulosite et de l'eau condensee

IF (.NOT.LLCONDWT) THEN
  DO JLEV=1,YDCPG_OPTS%KFLEVG
    DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
      ZDQVDT(JLON,JLEV)=ZDQVDT(JLON,JLEV)+ZDQLDT(JLON,JLEV)+ZDQIDT(JLON,JLEV)
      ZDTDT(JLON,JLEV)=ZDTDT(JLON,JLEV) - (ZLV(JLON,JLEV)*ZDQLDT(JLON,JLEV)&
        & + ZLS(JLON,JLEV)*ZDQIDT(JLON,JLEV)) / PCP(JLON,JLEV)
      ZDQLDT(JLON,JLEV)=0.0_JPRB
      ZDQIDT(JLON,JLEV)=0.0_JPRB
    ENDDO
  ENDDO
ELSE
  DO JLEV=1,YDCPG_OPTS%KFLEVG
    DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
      PFCCQL(JLON,JLEV)=PFCCQL(JLON,JLEV-1)+ZDPSG(JLON,JLEV)*ZDQLDT(JLON,JLEV)
      PFCCQN(JLON,JLEV)=PFCCQN(JLON,JLEV-1)+ZDPSG(JLON,JLEV)*ZDQIDT(JLON,JLEV)
    ENDDO
  ENDDO
ENDIF

DO JLEV=1,YDCPG_OPTS%KFLEVG
!DEC$ IVDEP
  DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
    PDIFCQ(JLON,JLEV)=PDIFCQ(JLON,JLEV-1)-ZDPSG(JLON,JLEV)*ZDQVDT(JLON,JLEV)
    ZTDCP=ZVMD*ZDQVDT(JLON,JLEV)+ZWMD*ZDQLDT(JLON,JLEV)+ZSMD*ZDQIDT(JLON,JLEV)
    PDIFCS(JLON,JLEV)=PDIFCS(JLON,JLEV-1)-ZDPSG(JLON,JLEV)&
     & * (ZDTDT(JLON,JLEV)*(PCP(JLON,JLEV)+TSPHY*ZTDCP)+PT(JLON,JLEV)*ZTDCP)
  ENDDO
ENDDO

DO JLEV=1,YDCPG_OPTS%KFLEVG
  DO JLON=YDCPG_BNDS%KIDIA,YDCPG_BNDS%KFDIA
    PDIFCQ(JLON,JLEV)=PDIFCQ(JLON,JLEV)-PFCCQL(JLON,JLEV)-PFCCQN(JLON,JLEV)
    PDIFCS(JLON,JLEV)=PDIFCS(JLON,JLEV)&
     & + RLVZER*PFCCQL(JLON,JLEV) + RLSZER*PFCCQN(JLON,JLEV)
  ENDDO
ENDDO

!$ACDC }

IF(LMUSCLFA) THEN

!$ACDC ABORT {

  CALL WRSCMR(NMUSCLFA,'ZMF_shal',ZUMF,YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG)

!$ACDC }

ENDIF

!-----------------------------------------------------------------
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('ACVPPKF',1,ZHOOK_HANDLE)
END SUBROUTINE ACVPPKF

