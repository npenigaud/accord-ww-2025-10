MODULE UTIL_SPP_MODEL_MOD

USE SPP_GEN_MOD, ONLY : SPP_MODEL

INTERFACE ACDC_SAVE
MODULE PROCEDURE ACDC_SAVE_SPP_MODEL
END INTERFACE

INTERFACE ACDC_LOAD
MODULE PROCEDURE ACDC_LOAD_SPP_MODEL
END INTERFACE

INTERFACE ACDC_COPY
MODULE PROCEDURE ACDC_COPY_SPP_MODEL
END INTERFACE

INTERFACE ACDC_HOST
MODULE PROCEDURE ACDC_HOST_SPP_MODEL
END INTERFACE


INTERFACE ACDC_CRC64
MODULE PROCEDURE ACDC_CRC64_SPP_MODEL
END INTERFACE

INTERFACE ACDC_WIPE
MODULE PROCEDURE ACDC_WIPE_SPP_MODEL
END INTERFACE

INTERFACE ACDC_SIZE
MODULE PROCEDURE ACDC_SIZE_SPP_MODEL
END INTERFACE

CONTAINS

SUBROUTINE ACDC_SAVE_SPP_MODEL (SELF, KLUN)
USE UTIL_spp_pert_MOD
IMPLICIT NONE
TYPE (SPP_MODEL), INTENT (IN), TARGET :: SELF
INTEGER, INTENT (IN) :: KLUN
INTEGER :: J1
WRITE (KLUN) SELF%VERSION
WRITE (KLUN) SELF%NMAX
WRITE (KLUN) SELF%DEFINED_PERTS
WRITE (KLUN) SELF%ACTIVE_PERTS
WRITE (KLUN) SELF%NDEF
WRITE (KLUN) SELF%NACT
WRITE (KLUN) SELF%NRFTOTAL
WRITE (KLUN) SELF%NRFTOTAL_RADGRID
WRITE (KLUN) SELF%NSEED_OFF
DO J1 = LBOUND (SELF%PNDEF, 1), UBOUND (SELF%PNDEF, 1)
  CALL ACDC_SAVE_spp_pert (SELF%PNDEF (J1), KLUN)
ENDDO
DO J1 = LBOUND (SELF%PN, 1), UBOUND (SELF%PN, 1)
  CALL ACDC_SAVE_spp_pert (SELF%PN (J1), KLUN)
ENDDO
WRITE (KLUN) SELF%TAU
WRITE (KLUN) SELF%XLCOR
WRITE (KLUN) SELF%SDEV
WRITE (KLUN) SELF%KSEED_OFF
END SUBROUTINE

SUBROUTINE ACDC_LOAD_SPP_MODEL (SELF, KLUN)
USE UTIL_spp_pert_MOD
USE PARKIND1, ONLY : JPRD
IMPLICIT NONE
TYPE (SPP_MODEL), INTENT (OUT), TARGET :: SELF
INTEGER, INTENT (IN) :: KLUN
INTEGER :: J1
REAL(KIND=JPRD) :: ZTMP0
READ (KLUN) SELF%VERSION
READ (KLUN) SELF%NMAX
READ (KLUN) SELF%DEFINED_PERTS
READ (KLUN) SELF%ACTIVE_PERTS
READ (KLUN) SELF%NDEF
READ (KLUN) SELF%NACT
READ (KLUN) SELF%NRFTOTAL
READ (KLUN) SELF%NRFTOTAL_RADGRID
READ (KLUN) SELF%NSEED_OFF
DO J1 = LBOUND (SELF%PNDEF, 1), UBOUND (SELF%PNDEF, 1)
  CALL ACDC_LOAD_spp_pert (SELF%PNDEF (J1), KLUN)
ENDDO
DO J1 = LBOUND (SELF%PN, 1), UBOUND (SELF%PN, 1)
  CALL ACDC_LOAD_spp_pert (SELF%PN (J1), KLUN)
ENDDO
READ (KLUN) ZTMP0
SELF%TAU = ZTMP0
READ (KLUN) ZTMP0
SELF%XLCOR = ZTMP0
READ (KLUN) ZTMP0
SELF%SDEV = ZTMP0
READ (KLUN) SELF%KSEED_OFF
END SUBROUTINE

SUBROUTINE ACDC_COPY_SPP_MODEL (SELF, LDCREATED, LDFIELDAPI)
USE UTIL_spp_pert_MOD
IMPLICIT NONE
TYPE (SPP_MODEL), INTENT (IN), TARGET :: SELF
LOGICAL, OPTIONAL, INTENT (IN) :: LDCREATED, LDFIELDAPI
LOGICAL :: LLCREATED
LOGICAL :: LLFIELDAPI
INTEGER :: J1
LLFIELDAPI = .FALSE.
IF (PRESENT (LDFIELDAPI)) THEN
  LLFIELDAPI = LDFIELDAPI
ENDIF
LLCREATED = .FALSE.
IF (PRESENT (LDCREATED)) THEN
  LLCREATED = LDCREATED
ENDIF
IF (.NOT. LLCREATED) THEN
  !$ACC ENTER DATA CREATE (SELF)
  !$ACC UPDATE DEVICE (SELF)
ENDIF

DO J1 = LBOUND (SELF%PNDEF, 1), UBOUND (SELF%PNDEF, 1)
  CALL ACDC_COPY_spp_pert (SELF%PNDEF (J1), LDCREATED=.TRUE., LDFIELDAPI=LDFIELDAPI)
ENDDO

DO J1 = LBOUND (SELF%PN, 1), UBOUND (SELF%PN, 1)
  CALL ACDC_COPY_spp_pert (SELF%PN (J1), LDCREATED=.TRUE., LDFIELDAPI=LDFIELDAPI)
ENDDO

END SUBROUTINE

SUBROUTINE ACDC_HOST_SPP_MODEL (SELF)
USE UTIL_spp_pert_MOD
IMPLICIT NONE
TYPE (SPP_MODEL), TARGET :: SELF
INTEGER :: J1

DO J1 = LBOUND (SELF%PNDEF, 1), UBOUND (SELF%PNDEF, 1)
  CALL ACDC_HOST_spp_pert (SELF%PNDEF (J1))
ENDDO

DO J1 = LBOUND (SELF%PN, 1), UBOUND (SELF%PN, 1)
  CALL ACDC_HOST_spp_pert (SELF%PN (J1))
ENDDO

END SUBROUTINE



SUBROUTINE ACDC_CRC64_SPP_MODEL (SELF, KLUN, CDPATH)
USE UTIL_spp_pert_MOD
USE FXTRAN_ACDC_CRC64_INTRINSIC_MOD, ONLY : FCRC64 => FXTRAN_ACDC_CRC64
IMPLICIT NONE
TYPE (SPP_MODEL), TARGET :: SELF
INTEGER, INTENT (IN) :: KLUN
CHARACTER(LEN=*), INTENT (IN) :: CDPATH
CHARACTER(LEN=128) :: CLIND
INTEGER :: J1
WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (SELF%VERSION), CDPATH//'%VERSION'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (SELF%NMAX), CDPATH//'%NMAX'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (SELF%DEFINED_PERTS), CDPATH//'%DEFINED_PERTS'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (SELF%ACTIVE_PERTS), CDPATH//'%ACTIVE_PERTS'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (SELF%NDEF), CDPATH//'%NDEF'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (SELF%NACT), CDPATH//'%NACT'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (SELF%NRFTOTAL), CDPATH//'%NRFTOTAL'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (SELF%NRFTOTAL_RADGRID), CDPATH//'%NRFTOTAL_RADGRID'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (SELF%NSEED_OFF), CDPATH//'%NSEED_OFF'

DO J1 = LBOUND (SELF%PNDEF, 1), UBOUND (SELF%PNDEF, 1)
  WRITE (CLIND, '("(",I0,")")') J1
  CALL ACDC_CRC64_spp_pert (SELF%PNDEF (J1), KLUN, CDPATH//'%PNDEF'//TRIM(CLIND))
ENDDO

DO J1 = LBOUND (SELF%PN, 1), UBOUND (SELF%PN, 1)
  WRITE (CLIND, '("(",I0,")")') J1
  CALL ACDC_CRC64_spp_pert (SELF%PN (J1), KLUN, CDPATH//'%PN'//TRIM(CLIND))
ENDDO

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (SELF%TAU), CDPATH//'%TAU'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (SELF%XLCOR), CDPATH//'%XLCOR'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (SELF%SDEV), CDPATH//'%SDEV'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (SELF%KSEED_OFF), CDPATH//'%KSEED_OFF'

END SUBROUTINE

SUBROUTINE ACDC_WIPE_SPP_MODEL (SELF, LDDELETED, LDFIELDAPI)
USE UTIL_spp_pert_MOD
IMPLICIT NONE
TYPE (SPP_MODEL), INTENT (IN), TARGET :: SELF
LOGICAL, OPTIONAL, INTENT (IN) :: LDDELETED, LDFIELDAPI
LOGICAL :: LLDELETED
LOGICAL :: LLFIELDAPI
INTEGER :: J1
LLFIELDAPI = .FALSE.
IF (PRESENT (LDFIELDAPI)) THEN
  LLFIELDAPI = LDFIELDAPI
ENDIF

DO J1 = LBOUND (SELF%PNDEF, 1), UBOUND (SELF%PNDEF, 1)
  CALL ACDC_WIPE_spp_pert (SELF%PNDEF (J1), LDDELETED=.TRUE., LDFIELDAPI=LDFIELDAPI)
ENDDO

DO J1 = LBOUND (SELF%PN, 1), UBOUND (SELF%PN, 1)
  CALL ACDC_WIPE_spp_pert (SELF%PN (J1), LDDELETED=.TRUE., LDFIELDAPI=LDFIELDAPI)
ENDDO

LLDELETED = .FALSE.
IF (PRESENT (LDDELETED)) THEN
  LLDELETED = LDDELETED
ENDIF
IF (.NOT. LLDELETED) THEN
  !$ACC EXIT DATA DELETE (SELF)
ENDIF
END SUBROUTINE

FUNCTION ACDC_SIZE_SPP_MODEL (SELF, CDPATH, LDPRINT) RESULT (KSIZE)
USE UTIL_spp_pert_MOD
IMPLICIT NONE
TYPE (SPP_MODEL),     INTENT (IN), TARGET :: SELF
CHARACTER(LEN=*), INTENT (IN), OPTIONAL :: CDPATH
LOGICAL,          INTENT (IN), OPTIONAL :: LDPRINT
INTEGER*8 :: KSIZE
INTEGER*8 :: ISIZE, JSIZE
LOGICAL :: LLPRINT
CHARACTER(LEN=128) :: CLPATH
INTEGER :: J1
LLPRINT = .FALSE.
IF (PRESENT (LDPRINT)) THEN
  LLPRINT = LDPRINT
ENDIF
CLPATH=''
IF (PRESENT (CDPATH)) THEN
  CLPATH = CDPATH
ENDIF
KSIZE = 0
ISIZE = KIND (SELF%VERSION) * LEN (SELF%VERSION)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%VERSION'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (SELF%NMAX)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%NMAX'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (SELF%DEFINED_PERTS) * SIZE (SELF%DEFINED_PERTS) * LEN (SELF%DEFINED_PERTS)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%DEFINED_PERTS'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (SELF%ACTIVE_PERTS) * SIZE (SELF%ACTIVE_PERTS) * LEN (SELF%ACTIVE_PERTS)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%ACTIVE_PERTS'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (SELF%NDEF)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%NDEF'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (SELF%NACT)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%NACT'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (SELF%NRFTOTAL)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%NRFTOTAL'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (SELF%NRFTOTAL_RADGRID)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%NRFTOTAL_RADGRID'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (SELF%NSEED_OFF) * SIZE (SELF%NSEED_OFF)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%NSEED_OFF'
ENDIF
KSIZE = KSIZE + ISIZE
JSIZE = 0
DO J1 = LBOUND (SELF%PNDEF, 1), UBOUND (SELF%PNDEF, 1)
  ISIZE = ACDC_SIZE_spp_pert (SELF%PNDEF (J1), CLPATH//'%PNDEF', .FALSE.)
  JSIZE = JSIZE + ISIZE
  KSIZE = KSIZE + ISIZE
ENDDO
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') JSIZE
  WRITE (*, *) TRIM (CLPATH)//'%PNDEF'
ENDIF
JSIZE = 0
DO J1 = LBOUND (SELF%PN, 1), UBOUND (SELF%PN, 1)
  ISIZE = ACDC_SIZE_spp_pert (SELF%PN (J1), CLPATH//'%PN', .FALSE.)
  JSIZE = JSIZE + ISIZE
  KSIZE = KSIZE + ISIZE
ENDDO
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') JSIZE
  WRITE (*, *) TRIM (CLPATH)//'%PN'
ENDIF
ISIZE = KIND (SELF%TAU)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%TAU'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (SELF%XLCOR)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%XLCOR'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (SELF%SDEV)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%SDEV'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (SELF%KSEED_OFF)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%KSEED_OFF'
ENDIF
KSIZE = KSIZE + ISIZE
END FUNCTION

END MODULE
