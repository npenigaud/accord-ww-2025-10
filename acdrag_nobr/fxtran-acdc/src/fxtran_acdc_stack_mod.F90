MODULE FXTRAN_ACDC_STACK_MOD

!
! Copyright 2025 Meteo-France
! All rights reserved
! philippe.marguinaud@meteo.fr
!

IMPLICIT NONE

INTEGER, PARAMETER :: JPIA = 8, JPIB = 8

TYPE FXTRAN_ACDC_STACK_DATA
  REAL (KIND=4), POINTER :: ZDATA4 (:,:,:,:)
  REAL (KIND=8), POINTER :: ZDATA8 (:,:,:,:)
  INTEGER (KIND=JPIB) :: IALIGN
CONTAINS
  PROCEDURE :: INIT => FXTRAN_ACDC_STACK_DATA_INIT
  PROCEDURE :: FINAL => FXTRAN_ACDC_STACK_DATA_FINAL
END TYPE

TYPE FXTRAN_ACDC_STACK
  INTEGER (KIND=JPIA) :: L4
  INTEGER (KIND=JPIA) :: U4
  INTEGER (KIND=JPIA) :: L8
  INTEGER (KIND=JPIA) :: U8
END TYPE

TYPE (FXTRAN_ACDC_STACK_DATA) :: YFXTRAN_ACDC_STACK

INTERFACE OPERATOR (+)
  MODULE PROCEDURE STACK_PLUS
END INTERFACE

INTERFACE OPERATOR (-)
  MODULE PROCEDURE STACK_MINUS
END INTERFACE

PRIVATE
PUBLIC :: FXTRAN_ACDC_STACK, YFXTRAN_ACDC_STACK, FXTRAN_ACDC_STACK_INIT, FXTRAN_ACDC_STACK_ALLOC, OPERATOR (+), OPERATOR (-)

CONTAINS

#ifdef __PGI
SUBROUTINE FXTRAN_ACDC_STACK_INIT (SELF, YDSTACK_DATA, KBLOCK, KGPBLKS, YDOFFSET) 
#else
FUNCTION FXTRAN_ACDC_STACK_INIT (YDSTACK_DATA, KBLOCK, KGPBLKS, YDOFFSET) RESULT (SELF)
#endif

!$acc routine seq

TYPE (FXTRAN_ACDC_STACK) :: SELF
TYPE (FXTRAN_ACDC_STACK_DATA), INTENT (IN) :: YDSTACK_DATA
INTEGER, INTENT (IN) :: KBLOCK, KGPBLKS
TYPE (FXTRAN_ACDC_STACK), INTENT (IN), OPTIONAL :: YDOFFSET

INTEGER (KIND=JPIA) :: IBASE4, IBASE8

INTEGER (KIND=JPIA) :: MALIGN, P, K
MALIGN (P, K) = ((P+K-1)/K) * K

IF (PRESENT (YDOFFSET)) THEN
  IBASE4 = YDOFFSET%L4
  IBASE8 = YDOFFSET%L8
ELSE
  IBASE4 = 0
  IBASE8 = 0
ENDIF

SELF%L4 =   IBASE4 + LOC (YDSTACK_DATA%ZDATA4 (1,1,1,1)) + ((INT (KBLOCK, 8) - 1)    &
        * (SIZE (YDSTACK_DATA%ZDATA4,KIND=8) * KIND (YDSTACK_DATA%ZDATA4) - IBASE4)) &
        / INT (KGPBLKS, 8)
SELF%U4 =   IBASE4 + LOC (YDSTACK_DATA%ZDATA4 (1,1,1,1)) + ((INT (KBLOCK, 8)    )    &
        * (SIZE (YDSTACK_DATA%ZDATA4,KIND=8) * KIND (YDSTACK_DATA%ZDATA4) - IBASE4)) &
        / INT (KGPBLKS, 8)

SELF%L8 =   IBASE8 + LOC (YDSTACK_DATA%ZDATA8 (1,1,1,1)) + ((INT (KBLOCK, 8) - 1)    &
        * (SIZE (YDSTACK_DATA%ZDATA8,KIND=8) * KIND (YDSTACK_DATA%ZDATA8) - IBASE8)) &
        / INT (KGPBLKS, 8)
SELF%U8 =   IBASE8 + LOC (YDSTACK_DATA%ZDATA8 (1,1,1,1)) + ((INT (KBLOCK, 8)    )    &
        * (SIZE (YDSTACK_DATA%ZDATA8,KIND=8) * KIND (YDSTACK_DATA%ZDATA8) - IBASE8)) &
        / INT (KGPBLKS, 8)

SELF%L4 = MALIGN(SELF%L4, YDSTACK_DATA%IALIGN)
SELF%L8 = MALIGN(SELF%L8, YDSTACK_DATA%IALIGN)

#ifdef __PGI
END SUBROUTINE
#else
END FUNCTION
#endif

TYPE (FXTRAN_ACDC_STACK) FUNCTION STACK_PLUS (YDSTACK1, YDSTACK2)
TYPE (FXTRAN_ACDC_STACK), INTENT (IN) :: YDSTACK1, YDSTACK2
STACK_PLUS%L4 = YDSTACK1%L4 + YDSTACK2%L4
STACK_PLUS%L8 = YDSTACK1%L8 + YDSTACK2%L8
END  FUNCTION
 
TYPE (FXTRAN_ACDC_STACK) FUNCTION STACK_MINUS (YDSTACK1, YDSTACK2)
TYPE (FXTRAN_ACDC_STACK), INTENT (IN) :: YDSTACK1, YDSTACK2
STACK_MINUS%L4 = YDSTACK1%L4 - YDSTACK2%L4
STACK_MINUS%L8 = YDSTACK1%L8 - YDSTACK2%L8
END  FUNCTION
 
SUBROUTINE FXTRAN_ACDC_STACK_ALLOC (SELF, KPTR, KSIZE, KKIND, CDFILE, KLINE)

!$acc routine seq

USE FXTRAN_ACDC_ABORT_MOD

TYPE (FXTRAN_ACDC_STACK) :: SELF
INTEGER (KIND=JPIA) :: KPTR
INTEGER (KIND=JPIB) :: KSIZE
INTEGER             :: KKIND
CHARACTER(LEN=*)    :: CDFILE
INTEGER             :: KLINE

SELECT CASE (KKIND)
  CASE (4) 

    KPTR = SELF%L4
   
    SELF%L4 = SELF%L4 + 4 * KSIZE
   
    IF (SELF%L4 > SELF%U4) GOTO 999

  CASE (8) 

    KPTR = SELF%L8

    SELF%L8 = SELF%L8 + 8 * KSIZE

    IF (SELF%L8 > SELF%U8) GOTO 999

  CASE DEFAULT

    GOTO 999

END SELECT

RETURN

999 CONTINUE

CALL FXTRAN_ACDC_ABORT (CDFILE)

END SUBROUTINE

SUBROUTINE FXTRAN_ACDC_STACK_DATA_INIT (SELF, KPROMA, KLEV, KGPBLKS, KSIZE4, KSIZE8)

USE ISO_C_BINDING
USE FXTRAN_ACDC_DEV_MALLOC_MOD

CLASS (FXTRAN_ACDC_STACK_DATA) :: SELF
INTEGER, INTENT (IN) :: KPROMA, KLEV, KGPBLKS
INTEGER, INTENT (IN), OPTIONAL :: KSIZE4, KSIZE8

CHARACTER*32 :: CLENV
INTEGER :: ISIZE4, ISIZE8

INTEGER (C_SIZE_T) :: ISIZE
TYPE (C_PTR) :: IADDR
INTEGER (C_INT) :: IDEV_MALLOC

IF (PRESENT (KSIZE4)) THEN
  ISIZE4 = KSIZE4
ELSE
  ISIZE4 = 0
  CALL GETENV ('FXTRAN_ACDC_STACKSIZE4', CLENV)
  IF (CLENV /= '') READ (CLENV, *) ISIZE4
ENDIF

IF (PRESENT (KSIZE8)) THEN
  ISIZE8 = KSIZE8
ELSE
  ISIZE8 = 0
  CALL GETENV ('FXTRAN_ACDC_STACKSIZE8', CLENV)
  IF (CLENV /= '') READ (CLENV, *) ISIZE8
ENDIF

SELF%IALIGN = 8

CALL FXTRAN_ACDC_HAS_DEV_MALLOC (IDEV_MALLOC)

IF (IDEV_MALLOC /= 0) THEN

  ISIZE = KIND (SELF%ZDATA4) * INT (KPROMA) * INT (KLEV) * INT (ISIZE4) * INT (KGPBLKS)
  CALL FXTRAN_ACDC_DEV_MALLOC (ISIZE, IADDR)
  CALL C_F_POINTER (IADDR, SELF%ZDATA4, SHAPE=[KPROMA, KLEV, ISIZE4, KGPBLKS])

  ISIZE = KIND (SELF%ZDATA8) * INT (KPROMA) * INT (KLEV) * INT (ISIZE8) * INT (KGPBLKS)
  CALL FXTRAN_ACDC_DEV_MALLOC (ISIZE, IADDR)
  CALL C_F_POINTER (IADDR, SELF%ZDATA8, SHAPE=[KPROMA, KLEV, ISIZE8, KGPBLKS])

ELSE

  ALLOCATE (SELF%ZDATA4 (KPROMA, KLEV, ISIZE4, KGPBLKS))

  ALLOCATE (SELF%ZDATA8 (KPROMA, KLEV, ISIZE8, KGPBLKS))

ENDIF

!$acc enter data create (SELF%ZDATA4)
!$acc enter data create (SELF%ZDATA8)

!$acc enter data create (SELF)
!$acc update device (SELF)
!$acc enter data attach (SELF%ZDATA4)
!$acc enter data attach (SELF%ZDATA8)

END SUBROUTINE

SUBROUTINE FXTRAN_ACDC_STACK_DATA_FINAL (SELF)

USE ISO_C_BINDING
USE FXTRAN_ACDC_DEV_MALLOC_MOD

CLASS (FXTRAN_ACDC_STACK_DATA) :: SELF

TYPE (C_PTR) :: IADDR
INTEGER (C_INT) :: IDEV_MALLOC

!$acc exit data detach (SELF%ZDATA8)
!$acc exit data detach (SELF%ZDATA4)

!$acc exit data delete (SELF)

!$acc exit data delete (SELF%ZDATA8)
!$acc exit data delete (SELF%ZDATA4)

CALL FXTRAN_ACDC_HAS_DEV_MALLOC (IDEV_MALLOC)

IF (IDEV_MALLOC /= 0) THEN

  IADDR = C_LOC (SELF%ZDATA8 (1, 1, 1, 1))
  CALL FXTRAN_ACDC_DEV_FREE (IADDR)

  IADDR = C_LOC (SELF%ZDATA4 (1, 1, 1, 1))
  CALL FXTRAN_ACDC_DEV_FREE (IADDR)

ELSE

  DEALLOCATE (SELF%ZDATA8)

  DEALLOCATE (SELF%ZDATA4)

ENDIF

END SUBROUTINE

END MODULE

